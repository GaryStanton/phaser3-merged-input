{"version":3,"sources":["webpack://MergedInput/webpack/universalModuleDefinition","webpack://MergedInput/./main.js","webpack://MergedInput/./configs/bearings.js","webpack://MergedInput/./controlManager.js","webpack://MergedInput/./configs/pad_generic.js","webpack://MergedInput/./configs/pad_unlicensedSNES.js","webpack://MergedInput/./configs/pad_xbox360.js","webpack://MergedInput/./configs/pad_dualshock.js","webpack://MergedInput/./ButtonCombo.js","webpack://MergedInput/../node_modules/phaser/src/input/keyboard/combo/AdvanceKeyCombo.js","webpack://MergedInput/../node_modules/phaser/src/input/keyboard/combo/ResetKeyCombo.js","webpack://MergedInput/webpack/bootstrap"],"names":["root","factory","exports","module","define","amd","window","MergedInput","scene","pluginManager","players","gamepads","keys","bearings","dpadMappings","controlManager","this","eventEmitter","systems","events","Phaser","Events","EventEmitter","game","on","Core","PRE_STEP","preupdate","POST_STEP","postupdate","BLUR","loseFocus","input","gamepad","thisGamepad","refreshGamepads","setupGamepad","refreshPads","total","emit","gamepadButtonDown","gamepadButtonUp","keyboard","keyboardKeyDown","keyboardKeyUp","mouse","disableContextMenu","thisPlayer","pointer","BEARING","BEARING_DEGREES","ANGLE","direction","mapDirectionsToBearing","BEARING_LAST","DEGREES","parseFloat","mapBearingToDegrees","DEGREES_LAST","direction_secondary","checkKeyboardInput","checkGamepadInput","checkPointerInput","clearBuffer","interaction","pressed","length","internal","fakedpadPressed","buffer","interaction_mapped","fakedpadReleased","released","thisKey","reset","device","id","player","index","action","addPlayer","thisButton","gamepadID","toLowerCase","mappedPad","mapGamepad","gamepadMapping","gamepadType","padType","buttons_mapped","filter","el","entries","fakedpad","buttons","numberOfButtons","Number","isInteger","newPlayer","setupControls","addPlayerHelperFunctions","push","pointerMove","pointerDown","pointerUp","isPressed","button","matchedButtons","Array","x","includes","isDown","matchedDirections","matchedPointer","matchedAll","isReleased","checkDown","duration","includeFirst","undefined","downButtons","t","timers","_tick","Math","Snap","Floor","sys","time","now","once","unmappedButtons","unmappedButton","getUnmappedButton","map","getMappedButton","setDevice","key","actions","Object","buttonID","toString","replace","find","mappedButton","buttonNo","dpadMapping","value","append","getPlayerActions","addKey","Input","Keyboard","KeyCodes","thisValue","TIMESTAMP","event","keyCode","playerIndex","getPlayerIndexFromKey","playerAction","getPlayerButtonFromKey","getPlayer","state","last","lastPressed","lastReleased","pad","fakedpadBuffer","Gamepad","Button","leftStick","y","UP","abs","gamepadFakeDPadPress","DOWN","up","down","LEFT","RIGHT","left","right","gamepadFakeDPadRelease","rightStick","b","threshold","angleToPointer","distance","pointerDirection","getBearingFromAngle","angle","position","Angle","Between","worldX","worldY","pointerAngle","leftButtonDown","rightButtonDown","middleButtonDown","backButtonDown","forwardButtonDown","moveTime","leftButtonReleased","rightButtonReleased","middleButtonReleased","backButtonReleased","forwardButtonReleased","config","ButtonCombo","numDirections","snap_interval","PI2","angleSnap","To","angleSnapDeg","RadToDeg","bearing","thisDirection","toUpperCase","directions","shutdown","debug","i","axes","a","axis","getValue","Plugins","ScenePlugin","padConfig","pad_generic","pad_unlicensedSNES","pad_xbox360","pad_dualshock","RC_S","RC_E","RC_W","RC_N","START","SELECT","LB","RB","LT","RT","LS","RS","LC_N","LC_S","LC_W","LC_E","MENU","controls","getBaseControls","thisPointer","setPosition","padID","TOUCH","mergedInput","keyCodes","onButtonDown","current","matched","enabled","ProcessButtonCombo","combo","resetOnMatch","deleteOnMatch","destroy","buttonMatch","comboMatched","keyMatched","maxKeyDelay","timeLimit","timeLastMatched","timeStamp","resetOnWrongKey","timeMatched","off","KeyCombo","size","installedModules","__webpack_require__","m","modules","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","mode","__esModule","ns","create","bind","n","object","property","prototype","hasOwnProperty","call","p","s","moduleId","l"],"mappings":"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","file":"MergedInput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"MergedInput\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MergedInput\"] = factory();\n\telse\n\t\troot[\"MergedInput\"] = factory();\n})(window, function() {\nreturn ","import bearings from './configs/bearings'\r\nimport controlManager from './controlManager'\r\nimport ButtonCombo from './ButtonCombo'\r\n\r\nexport default class MergedInput extends Phaser.Plugins.ScenePlugin {\r\n\r\n\t/**\r\n\t * The Merged Input plugin is designed to run in the background and handle input.\r\n\t * Upon detecting a keypress or gamepad interaction, the plugin will update a player object and emit global events.\r\n\t *\r\n\t * @extends Phaser.Plugins.ScenePlugin\r\n\t * @param {*} scene\r\n\t * @param {*} pluginManager\r\n\t */\r\n\tconstructor(scene, pluginManager) {\r\n\t\tsuper(scene, pluginManager);\r\n\t\tthis.scene = scene;\r\n\r\n\t\t// Players\r\n\t\tthis.players = [];\r\n\t\t// Gamepads\r\n\t\tthis.gamepads = [];\r\n\t\t// Keys object to store Phaser key objects. We'll check these during update\r\n\t\tthis.keys = {};\r\n\r\n\t\tthis.bearings = bearings;\r\n\r\n\t\tthis.dpadMappings = {\r\n\t\t\t'UP': 12,\r\n\t\t\t'DOWN': 13,\r\n\t\t\t'LEFT': 14,\r\n\t\t\t'RIGHT': 15\r\n\t\t}\r\n\r\n\t\tthis.controlManager = new controlManager()\r\n\t}\r\n\r\n\tboot() {\r\n\t\t// Scene event emitter\r\n\t\tthis.eventEmitter = this.systems.events;\r\n\t\t// Plugin event emitter\r\n\t\tthis.events = new Phaser.Events.EventEmitter();\r\n\r\n\t\tthis.game.events.on(Phaser.Core.Events.PRE_STEP, this.preupdate, this);\r\n\t\tthis.game.events.on(Phaser.Core.Events.POST_STEP, this.postupdate, this);\r\n\t\t// Handle the game losing focus\r\n\t\tthis.game.events.on(Phaser.Core.Events.BLUR, () => {\r\n\t\t\tthis.loseFocus()\r\n\t\t})\r\n\r\n\t\t// Gamepad\r\n\t\tif (typeof this.systems.input.gamepad !== 'undefined') {\r\n\t\t\tthis.systems.input.gamepad.on('connected', function (thisGamepad) {\r\n\t\t\t\tthis.refreshGamepads();\r\n\t\t\t\tthis.setupGamepad(thisGamepad)\r\n\t\t\t}, this);\r\n\r\n\t\t\t// Check to see if the gamepad has already been setup by the browser\r\n\t\t\tthis.systems.input.gamepad.refreshPads();\r\n\t\t\tif (this.systems.input.gamepad.total) {\r\n\t\t\t\tthis.refreshGamepads();\r\n\t\t\t\tfor (const thisGamepad of this.gamepads) {\r\n\t\t\t\t\tthis.systems.input.gamepad.emit('connected', thisGamepad);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.systems.input.gamepad.on('down', this.gamepadButtonDown, this);\r\n\t\t\tthis.systems.input.gamepad.on('up', this.gamepadButtonUp, this);\r\n\t\t}\r\n\r\n\t\t// Keyboard\r\n\t\tthis.systems.input.keyboard.on('keydown', this.keyboardKeyDown, this);\r\n\t\tthis.systems.input.keyboard.on('keyup', this.keyboardKeyUp, this);\r\n\r\n\r\n\t\t// Pointer\r\n\t\tthis.systems.input.mouse.disableContextMenu();\r\n\t}\r\n\r\n\tpreupdate() {\r\n\t\t// Loop through players and handle input\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\t// If the pointer hasn't moved, and the scene has changed, this can end up as undefined\r\n\t\t\tthisPlayer.pointer.BEARING = typeof thisPlayer.pointer.BEARING != 'undefined' ? thisPlayer.pointer.BEARING : '';\r\n\t\t\tthisPlayer.pointer.BEARING_DEGREES = typeof thisPlayer.pointer.BEARING_DEGREES != 'undefined' ? thisPlayer.pointer.BEARING_DEGREES : 0;\r\n\t\t\tthisPlayer.pointer.ANGLE = typeof thisPlayer.pointer.ANGLE != 'undefined' ? thisPlayer.pointer.ANGLE : '';\r\n\r\n\r\n\t\t\tthisPlayer.direction.BEARING = this.mapDirectionsToBearing(thisPlayer.direction);\r\n\t\t\tthisPlayer.direction.BEARING_LAST = thisPlayer.direction.BEARING != '' ? thisPlayer.direction.BEARING : thisPlayer.direction.BEARING_LAST;\r\n\t\t\tthisPlayer.direction.DEGREES = thisPlayer.direction.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING)) : 0;\r\n\t\t\tthisPlayer.direction.DEGREES_LAST = thisPlayer.direction.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING_LAST)) : 0;\r\n\t\t\tthisPlayer.direction_secondary.BEARING = this.mapDirectionsToBearing(thisPlayer.direction_secondary);\r\n\t\t\tthisPlayer.direction_secondary.BEARING_LAST = thisPlayer.direction_secondary.BEARING != '' ? thisPlayer.direction_secondary.BEARING : thisPlayer.direction_secondary.BEARING_LAST;\r\n\t\t\tthisPlayer.direction_secondary.DEGREES = thisPlayer.direction_secondary.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING)) : 0;\r\n\t\t\tthisPlayer.direction_secondary.DEGREES_LAST = thisPlayer.direction_secondary.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING_LAST)) : 0;\r\n\t\t}\r\n\r\n\t\tthis.checkKeyboardInput();\r\n\t\tthis.checkGamepadInput();\r\n\t\tthis.checkPointerInput();\r\n\t}\r\n\r\n\tpostupdate() {\r\n\t\t// Loop through players and manage buffered input\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\t// Clear the interaction buffer\r\n\t\t\tthis.clearBuffer(thisPlayer);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the interaction buffer for the given player\r\n\t * In the case of 'fake' DPad presses, we're using some convoluted buffers to keep the 'pressed' and 'released' values around for an extra tick\r\n\t * As they're created in this update loop, they're otherwise cleared before the consumer can use them.\r\n\t * @param {*} thisPlayer \r\n\t */\r\n\tclearBuffer(thisPlayer) {\r\n\t\tif (thisPlayer.interaction.pressed.length > 0 && thisPlayer.internal.fakedpadPressed.length == 0) {\r\n\t\t\tthisPlayer.interaction.buffer = [];\r\n\t\t}\r\n\t\tif (thisPlayer.interaction.buffer.length == 0) {\r\n\t\t\tthisPlayer.interaction.pressed = [];\r\n\t\t\tthisPlayer.interaction_mapped.pressed = [];\r\n\t\t\tif (thisPlayer.internal.fakedpadReleased.length == 0) {\r\n\t\t\t\tthisPlayer.interaction.released = [];\r\n\t\t\t\tthisPlayer.interaction_mapped.released = [];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthisPlayer.internal.fakedpadPressed = [];\r\n\t\tthisPlayer.internal.fakedpadReleased = [];\r\n\t}\r\n\r\n\t/**\r\n\t * Function to run when the game loses focus\r\n\t * We want to fake releasing the buttons here, so that they're not stuck down without an off event when focus returns to the game\r\n\t */\r\n\tloseFocus() {\r\n\t\t// Loop through defined keys and reset them\r\n\t\tfor (let thisKey in this.keys) {\r\n\t\t\tthis.keys[thisKey].reset();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set up the gamepad and associate with a player object\r\n\t */\r\n\tsetupGamepad(thisGamepad) {\r\n\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', id: thisGamepad.id, player: thisGamepad.index, action: 'Connected' });\r\n\t\tthis.events.emit('gamepad_connected', thisGamepad)\r\n\r\n\t\tif (typeof this.players[thisGamepad.index] === 'undefined') {\r\n\t\t\tthis.addPlayer();\r\n\t\t}\r\n\t\t\r\n\t\tlet gamepadID = thisGamepad.id.toLowerCase();\r\n\t\tthis.players[thisGamepad.index].gamepad = thisGamepad;\r\n\r\n\t\t// Map the gamepad buttons\r\n\t\tlet mappedPad = this.controlManager.mapGamepad(gamepadID);\r\n\t\tthis.players[thisGamepad.index].gamepadMapping = mappedPad.gamepadMapping;\r\n\t\tthis.players[thisGamepad.index].interaction_mapped.gamepadType = mappedPad.padType;\r\n\t\tfor (let thisButton in this.players[thisGamepad.index].gamepadMapping) {\r\n\t\t\tthis.players[thisGamepad.index].buttons_mapped[thisButton] = 0;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\trefreshGamepads() {\r\n\t\t// Sometimes, gamepads are undefined. For some reason.\r\n\t\tthis.gamepads = this.systems.input.gamepad.gamepads.filter(function (el) {\r\n\t\t\treturn el != null;\r\n\t\t});\r\n\r\n\t\tfor (const [index, thisGamepad] of this.gamepads.entries()) {\r\n\t\t\tthisGamepad.index = index; // Overwrite the gamepad index, in case we had undefined gamepads earlier\r\n\r\n\t\t\t/**\r\n\t\t\t * Some cheap gamepads use the first axis as a dpad, in which case we won't have the dpad buttons 12-15\r\n\t\t\t */\r\n\t\t\tthisGamepad.fakedpad = thisGamepad.buttons.length < 15;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Add a new player object to the players array\r\n\t * @param {number} index Player index - if a player object at this index already exists, it will be returned instead of creating a new player object\r\n\t * @param {number} numberOfButtons The number of buttons to assign to the player object. Defaults to 16. Fewer than 16 is not recommended, as gamepad DPads typically map to buttons 12-15\r\n\t */\r\n\taddPlayer(index, numberOfButtons) {\r\n\t\tnumberOfButtons = numberOfButtons || 16;\r\n\t\tif (typeof Number.isInteger(index) && typeof this.players[index] !== 'undefined') {\r\n\t\t\treturn this.players[index];\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Set up player object\r\n\t\t\tlet newPlayer = this.controlManager.setupControls(numberOfButtons);\r\n\r\n\t\t\t// Add helper functions to the player object\r\n\t\t\tthis.addPlayerHelperFunctions(newPlayer);\r\n\r\n\t\t\t// Push new player to players array\r\n\t\t\tthis.players.push(newPlayer);\r\n\r\n\t\t\tthis.players[this.players.length - 1].index = this.players.length - 1;\r\n\r\n\t\t\t// If this is the first player, add the pointer events\r\n\t\t\tif (this.players.length == 1) {\r\n\t\t\t\tthis.systems.input.on('pointermove', function (pointer) {\r\n\t\t\t\t\tthis.pointerMove(pointer);\r\n\t\t\t\t}, this);\r\n\t\r\n\t\t\t\tthis.systems.input.on('pointerdown', function (pointer) {\r\n\t\t\t\t\tthis.pointerDown(pointer);\r\n\t\t\t\t}, this);\r\n\t\r\n\t\t\t\tthis.systems.input.on('pointerup', function (pointer) {\r\n\t\t\t\t\tthis.pointerUp(pointer);\r\n\t\t\t\t}, this);\r\n\t\t\t}\r\n\r\n\t\t\treturn this.players[this.players.length - 1];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Add helper functions to the player object\r\n\t * @param {*} player \r\n\t */\r\n\taddPlayerHelperFunctions(player) {\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any were pressed in this update step.\r\n\t\t * This will only fire once per button press. If you need to check for a button being held down, use isDown instead.\r\n\t\t * Returns the name of the matched button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.interaction.isPressed = (button) => {\r\n\t\t\tbutton = (typeof button === 'string') ? Array(button) : button;\r\n\t\t\tlet matchedButtons = button.filter(x => player.interaction.pressed.includes(x))\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any are currently pressed in this update step.\r\n\t\t * This differs from the isPressed function in that it will return true if the button is currently pressed, even if it was pressed in a previous update step.\r\n\t\t * Returns the name of the matched button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.interaction.isDown = (button) => {\r\n\t\t\tbutton = (typeof button === 'string') ? Array(button) : button;\r\n\t\t\tlet matchedButtons = button.filter(x => player.buttons[x])\r\n\t\t\tlet matchedDirections = button.filter(x => player.direction[x])\r\n\t\t\tlet matchedPointer = button.filter(x => player.pointer[x])\r\n\t\t\tlet matchedAll = [...matchedButtons, ...matchedDirections, ...matchedPointer];\r\n\r\n\t\t\treturn matchedAll.length ? matchedAll : false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any were released in this update step.\r\n\t\t * Returns the name of the matched button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.interaction.isReleased = (button) => {\r\n\t\t\tbutton = (typeof button === 'string') ? Array(button) : button;\r\n\t\t\tlet matchedButtons = button.filter(x => player.interaction.released.includes(x))\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Pass a mapped button name, or an array of mapped button names to check if any were pressed in this update step.\r\n\t\t * This will only fire once per button press. If you need to check for a button being held down, use isDown instead.\r\n\t\t * Returns the name of the matched mapped button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.interaction_mapped.isPressed = (button) => {\r\n\t\t\tbutton = (typeof button === 'string') ? Array(button) : button;\r\n\t\t\tlet matchedButtons = button.filter(x => player.interaction_mapped.pressed.includes(x))\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Pass a mapped button name, or an array of mapped button names to check if any are currently pressed in this update step.\r\n\t\t * This differs from the isPressed function in that it will return true if the button is currently pressed, even if it was pressed in a previous update step.\r\n\t\t * Returns the name of the matched button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.interaction_mapped.isDown = (button) => {\r\n\t\t\tbutton = (typeof button === 'string') ? Array(button) : button;\r\n\t\t\tlet matchedButtons = button.filter(x => player.buttons_mapped[x])\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Pass a mapped button name, or an array of mapped button names to check if any were released in this update step.\r\n\t\t * Returns the name of the matched mapped button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.interaction_mapped.isReleased = (button) => {\r\n\t\t\tbutton = (typeof button === 'string') ? Array(button) : button;\r\n\t\t\tlet matchedButtons = button.filter(x => player.interaction_mapped.released.includes(x))\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any are currently pressed in this update step.\r\n\t\t * Similar to Phaser's keyboard plugin, the checkDown function can accept a 'duration' parameter, and will only register a press once every X milliseconds.\r\n\t\t * Returns the name of the matched button(s)\r\n\t\t *\r\n\t\t * @param {string|array} button Array of buttons to check\r\n\t\t * @param {number} duration The duration which must have elapsed before this button is considered as being down.\r\n\t\t * @param {boolean} includeFirst - When true, the initial press of the button will be included in the results. Defaults to false.\r\n\t\t */\r\n\t\tplayer.interaction.checkDown = (button, duration, includeFirst) => {\r\n\t\t\tif (includeFirst === undefined) { includeFirst = false; }\r\n\t\t\tif (duration === undefined) { duration = 0; }\r\n\t\t\t\r\n\t\t\tlet matchedButtons = [];\r\n\t\t\tlet downButtons = player.interaction.isDown(button)\r\n\t\t\tif (downButtons.length) {\r\n\r\n\t\t\t\tfor (let thisButton of downButtons) {\r\n\t\t\t\t\tif (typeof player.timers[thisButton]._tick === 'undefined') {\r\n\t\t\t\t\t\tplayer.timers[thisButton]._tick = 0;\r\n\t\t\t\t\t\tif (includeFirst) {\r\n\t\t\t\t\t\t\tmatchedButtons.push(thisButton);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tlet t = Phaser.Math.Snap.Floor(this.scene.sys.time.now - player.timers[thisButton].pressed, duration);\r\n\t\t\t\t\tif (t > player.timers[thisButton]._tick) {\r\n\t\t\t\t\t\tthis.game.events.once(Phaser.Core.Events.POST_STEP, ()=>{\r\n\t\t\t\t\t\t\tplayer.timers[thisButton]._tick = t;\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\tmatchedButtons.push(thisButton);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false;\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Mapped version of the checkDown version - resolves mapped button names and calls the checkDown function\r\n\t\t */\r\n\t\t\tplayer.interaction_mapped.checkDown = (button, duration, includeFirst) => {\r\n\t\t\tif (includeFirst === undefined) { includeFirst = false; }\r\n\t\t\tlet unmappedButtons = [];\r\n\r\n\t\t\t// Resolve the unmapped button names to a new array\r\n\t\t\tfor (let thisButton of button) {\r\n\t\t\t\tlet unmappedButton = this.getUnmappedButton(player, thisButton);\r\n\r\n\t\t\t\tif (unmappedButton) {\r\n\t\t\t\t\tunmappedButtons.push(unmappedButton)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet downButtons = player.interaction.checkDown(unmappedButtons, duration, includeFirst);\r\n\t\t\treturn downButtons.length ? downButtons.map(x => this.getMappedButton(player, x)) : false;\r\n \t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * The previous functions are specific to the interaction and interaction_mapped definition of buttons.\r\n\t\t * In general you would pick a definition scheme and query that object (interaction or interaction_mapped), just for ease though, we'll add some functions that accept either type of convention\r\n\t\t */\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any were pressed in this update step.\r\n\t\t * This will only fire once per button press. If you need to check for a button being held down, use isDown instead.\r\n\t\t * Returns the name of the matched button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.isPressed = (button) => {\r\n\t\t\tlet interaction = player.interaction.isPressed(button) || [];\r\n\t\t\tlet interaction_mapped = player.interaction_mapped.isPressed(button) || [];\r\n\t\t\tlet matchedButtons = [...interaction, ...interaction_mapped];\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any are currently pressed in this update step.\r\n\t\t * This differs from the isPressed function in that it will return true if the button is currently pressed, even if it was pressed in a previous update step.\r\n\t\t * Returns the name of the button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.isDown = (button) => {\r\n\t\t\tlet interaction = player.interaction.isDown(button) || [];\r\n\t\t\tlet interaction_mapped = player.interaction_mapped.isDown(button) || [];\r\n\t\t\tlet matchedButtons = [...interaction, ...interaction_mapped];\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false\r\n\t\t},\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any were released in this update step.\r\n\t\t * Returns the name of the matched button(s), in case you need it.\r\n\t\t */\r\n\t\tplayer.isReleased = (button) => {\r\n\t\t\tlet interaction = player.interaction.isReleased(button) || [];\r\n\t\t\tlet interaction_mapped = player.interaction_mapped.isReleased(button) || [];\r\n\t\t\tlet matchedButtons = [...interaction, ...interaction_mapped];\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false\r\n\t\t}\r\n\r\n\r\n\t\t/**\r\n\t\t * Pass a button name, or an array of button names to check if any are currently pressed in this update step.\r\n\t\t * Similar to Phaser's keyboard plugin, the checkDown function can accept a 'duration' parameter, and will only register a press once every X milliseconds.\r\n\t\t * Returns the name of the matched button(s)\r\n\t\t *\r\n\t\t * @param {string|array} button Array of buttons to check\r\n\t\t * @param {number} - The duration which must have elapsed before this button is considered as being down.\r\n\t\t */\r\n\t\tplayer.checkDown = (button, duration, includeFirst) => {\r\n\t\t\tif (includeFirst === undefined) { includeFirst = false; }\r\n\t\t\tlet interaction = player.interaction.checkDown(button, duration, includeFirst) || [];\r\n\t\t\tlet interaction_mapped = player.interaction_mapped.checkDown(button, duration, includeFirst) || [];\r\n\t\t\tlet matchedButtons = [...interaction, ...interaction_mapped];\r\n\t\t\treturn matchedButtons.length ? matchedButtons : false\r\n\t\t}\r\n\t\t\r\n\r\n\t\tplayer.setDevice = (device) => {\r\n\t\t\tif (player.interaction.device != device) {\r\n\t\t\t\tthis.eventEmitter.emit('mergedInput', { device: device, player: player.index, action: 'Device Changed' });\r\n\t\t\t\tthis.events.emit('device_changed', { player: player.index, device: device });\r\n\t\t\t}\r\n\t\t\tplayer.interaction.device = device;\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Get player object\r\n\t * @param {number} index Player index\r\n\t */\r\n\tgetPlayer(index) {\r\n\t\treturn typeof this.players[index] !== 'undefined' ? this.players[index] : ''\r\n\t}\r\n\r\n\tgetPlayerIndexFromKey(key) {\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\t// Loop through all the keys assigned to this player\r\n\t\t\tfor (var thisKey in thisPlayer.keys) {\r\n\t\t\t\tfor (var thisValue of thisPlayer.keys[thisKey]) {\r\n\t\t\t\t\tif (thisValue == key) {\r\n\t\t\t\t\t\treturn thisPlayer.index;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tgetPlayerButtonFromKey(key) {\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\t// Loop through all the keys assigned to this player\r\n\t\t\tfor (var thisKey in thisPlayer.keys) {\r\n\t\t\t\tfor (var thisValue of thisPlayer.keys[thisKey]) {\r\n\t\t\t\t\tif (thisValue == key) {\r\n\t\t\t\t\t\t// Now we have a matching button value, check to see if it's in our mapped buttons, in which case we want to return the button number it matches to\r\n\t\t\t\t\t\tif (typeof thisPlayer.gamepadMapping[thisKey] !== \"undefined\") {\r\n\t\t\t\t\t\t\treturn 'B' + thisPlayer.gamepadMapping[thisKey];\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\treturn thisKey;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn '';\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Return an array of actions that a player may use\r\n\t * @param {number} player \r\n\t * @returns \r\n\t */\r\n\tgetPlayerActions(player) {\r\n\t\tlet actions = ['UP', 'DOWN', 'LEFT', 'RIGHT', 'ALT_UP', 'ALT_DOWN', 'ALT_LEFT', 'ALT_RIGHT'];\r\n\t\tactions.push(...Object.keys(this.players[player].gamepadMapping));\r\n\t\tactions.push(...Object.keys(this.players[player].buttons));\r\n\r\n\t\treturn actions;\r\n\t}\r\n\r\n\t/**\r\n\t * Given a player and a button ID, return the mapped button name, e.g. 0 = 'RC_S' (Right cluster, South - X on an xbox gamepad)\r\n\t * @param {*} player \r\n\t * @param {*} buttonID \r\n\t */\r\n\tgetMappedButton(player, buttonID) {\r\n\t\tbuttonID = buttonID.toString().replace(/\\D/g, '');\r\n\t\treturn Object.keys(player.gamepadMapping).find(key => player.gamepadMapping[key] == buttonID);\r\n\t}\r\n\r\n\t/**\r\n\t * Given a player and a mapped button name, return the button ID that it resolves to, e.g. 'RC_S' (Right cluster, South - X on an xbox gamepad) = B0.\r\n\t * This takes directions into account and will thus return 'LEFT' for LC_W, instead of the button ID that can be found in the gamepadMapping.\r\n\t * @param {*} player \r\n\t * @param {*} mappedButton \r\n\t */\r\n\tgetUnmappedButton(player, mappedButton) {\r\n\t\tlet buttonNo = player.gamepadMapping[mappedButton];\r\n\t\tlet dpadMapping = this.dpadMappings;\r\n\t\tlet direction = Object.keys(dpadMapping).find(key => dpadMapping[key] == buttonNo);\r\n\r\n\t\treturn direction ? direction : 'B' + player.gamepadMapping[mappedButton];\r\n\t}\r\n\r\n\t// Keyboard functions\r\n\r\n\t/**\r\n\t * Define a key for a player/action combination\r\n\t * @param {number} player The player on which we're defining a key\r\n\t * @param {string} action The action to define\r\n\t * @param {string} value The key to use\r\n\t * @param {boolean} append When true, this key definition will be appended to the existing key(s) for this action\r\n\t */\r\n\tdefineKey(player = 0, action, value, append = false) {\r\n\t\t// Set up a new player if none defined\r\n\t\tif (typeof this.players[player] === 'undefined') {\r\n\t\t\tthis.addPlayer();\r\n\t\t}\r\n\r\n\t\tif (this.getPlayerActions(player).includes(action)) {\r\n\t\t\tif (append && (typeof this.players[player].keys[action] !== 'undefined')) {\r\n\t\t\t\tthis.players[player].keys[action].push([value]);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.players[player].keys[action] = [];\r\n\t\t\t\tthis.players[player].keys[action].push([value]);\r\n\t\t\t}\r\n\r\n\t\t\tthis.keys[[value]] = this.systems.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[value]);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterate through players and check for interaction with defined keys\r\n\t */\r\n\tcheckKeyboardInput() {\r\n\t\t// Loop through players and check for keypresses\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\t// Loop through all the keys assigned to this player\r\n\t\t\tfor (var thisKey in thisPlayer.keys) {\r\n\t\t\t\tlet action = 0;\r\n\t\t\t\tfor (var thisValue of thisPlayer.keys[thisKey]) {\r\n\t\t\t\t\t// Check if the key is down\r\n\t\t\t\t\taction = (this.keys[thisValue].isDown) ? 1 : action;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set the action in the player object\r\n\r\n\t\t\t\t// Dpad\r\n\t\t\t\tif (['UP', 'DOWN', 'LEFT', 'RIGHT'].includes(thisKey)) {\r\n\t\t\t\t\tthisPlayer.direction[thisKey] = action;\r\n\t\t\t\t\tthisPlayer.direction.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t}\r\n\t\t\t\t// Alternative direction\r\n\t\t\t\telse if (['ALT_UP', 'ALT_DOWN', 'ALT_LEFT', 'ALT_RIGHT'].includes(thisKey)) {\r\n\t\t\t\t\tthisPlayer.direction_secondary[thisKey.replace('ALT_', '')] = action;\r\n\t\t\t\t\tif (action == 1) {\r\n\t\t\t\t\t\tthisPlayer.direction_secondary.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Friendly button names\r\n\t\t\t\telse if (thisKey in thisPlayer.gamepadMapping) {\r\n\t\t\t\t\t// Get the button number from the gamepad mapping\r\n\t\t\t\t\tthisPlayer.buttons['B' + thisPlayer.gamepadMapping[thisKey]] = action;\r\n\t\t\t\t\tthisPlayer.buttons_mapped[thisKey] = action;\r\n\t\t\t\t\tif (action == 1) {\r\n\t\t\t\t\t\tthisPlayer.buttons.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// Numbered buttons\r\n\t\t\t\telse {\r\n\t\t\t\t\tthisPlayer.buttons[thisKey] = action;\r\n\t\t\t\t\tif (action == 1) {\r\n\t\t\t\t\t\tthisPlayer.buttons.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Set the latest interaction flag\r\n\t\t\t\tif (action == 1) {\r\n\t\t\t\t\tthisPlayer.setDevice('keyboard');\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * When a keyboard button is pressed down, this function will emit a mergedInput event in the global registry.\r\n\t * The event contains a reference to the player assigned to the key, and passes a mapped action and value\r\n\t */\r\n\tkeyboardKeyDown(event) {\r\n\t\tlet keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(key => Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode);\r\n\t\tlet playerIndex = this.getPlayerIndexFromKey(keyCode);\r\n\t\tlet playerAction = this.getPlayerButtonFromKey(keyCode);\r\n\r\n\t\tif (playerIndex > -1 && playerAction != '') {\r\n\t\t\tlet thisPlayer = this.getPlayer(playerIndex);\r\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'keyboard', value: 1, player: playerIndex, action: keyCode, state: 'DOWN' });\r\n\t\t\tthis.events.emit('keyboard_keydown', { player: playerIndex, key: keyCode });\r\n\r\n\t\t\tthisPlayer.setDevice('keyboard');\r\n\t\t\tthisPlayer.interaction.pressed.push(playerAction);\r\n\t\t\tthisPlayer.interaction.buffer.push(playerAction);\r\n\t\t\tthisPlayer.interaction.last = playerAction;\r\n\t\t\tthisPlayer.interaction.lastPressed = playerAction;\r\n\r\n\t\t\t// Update timers\r\n\t\t\tthisPlayer.timers[playerAction].pressed = this.scene.sys.time.now;\r\n\t\t\tthisPlayer.timers[playerAction].released = 0;\r\n\t\t\tthisPlayer.timers[playerAction].duration = 0;\r\n\r\n\t\t\t// Update mapped button object\r\n\t\t\tif (typeof this.dpadMappings[playerAction] !== \"undefined\") {\r\n\t\t\t\tplayerAction = 'B' + this.dpadMappings[playerAction];\r\n\t\t\t}\r\n\t\t\tif (typeof thisPlayer.buttons[playerAction] !== \"undefined\") {\r\n\t\t\t\tlet mappedButton = this.getMappedButton(thisPlayer, playerAction);\r\n\t\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\t\tthisPlayer.buttons_mapped[mappedButton] = 1;\r\n\t\t\t\t\tthisPlayer.interaction_mapped.pressed.push(mappedButton);\r\n\t\t\t\t\tthisPlayer.interaction_mapped.last = mappedButton;\r\n\t\t\t\t\tthisPlayer.interaction_mapped.lastPressed = mappedButton;\r\n\t\t\t\t\tthisPlayer.interaction_mapped.gamepadType = 'keyboard';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * When a keyboard button is released, this function will emit a mergedInput event in the global registry.\r\n\t * The event contains a reference to the player assigned to the key, and passes a mapped action and value\r\n\t */\r\n\tkeyboardKeyUp(event) {\r\n\t\tlet keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(key => Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode);\r\n\t\tlet playerIndex = this.getPlayerIndexFromKey(keyCode);\r\n\t\tlet playerAction = this.getPlayerButtonFromKey(keyCode);\r\n\r\n\t\tif (playerIndex > -1 && playerAction != '') {\r\n\t\t\tlet thisPlayer = this.getPlayer(playerIndex);\r\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'keyboard', value: 1, player: playerIndex, action: keyCode, state: 'DOWN' });\r\n\t\t\tthis.events.emit('keyboard_keyup', { player: playerIndex, key: keyCode });\r\n\r\n\t\t\tthisPlayer.setDevice('keyboard');\r\n\t\t\tthisPlayer.interaction.released.push(playerAction);\r\n\t\t\tthisPlayer.interaction.lastReleased = playerAction;\r\n\t\t\t\r\n\t\t\t// Update timers\r\n\t\t\tthisPlayer.timers[playerAction].released = this.scene.sys.time.now;\r\n\t\t\tthisPlayer.timers[playerAction].duration = thisPlayer.timers[playerAction].released - thisPlayer.timers[playerAction].pressed;\r\n\t\t\tdelete thisPlayer.timers[playerAction]._tick;\r\n\r\n\t\t\t// Update mapped button object\r\n\t\t\tif (typeof this.dpadMappings[playerAction] !== \"undefined\") {\r\n\t\t\t\tplayerAction = 'B' + this.dpadMappings[playerAction];\r\n\t\t\t}\r\n\t\t\tif (typeof thisPlayer.buttons[playerAction] !== \"undefined\") {\r\n\t\t\t\tlet mappedButton = this.getMappedButton(thisPlayer, playerAction);\r\n\t\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\t\tthisPlayer.buttons_mapped[mappedButton] = 0;\r\n\t\t\t\t\tthisPlayer.interaction_mapped.released = mappedButton;\r\n\t\t\t\t\tthisPlayer.interaction_mapped.lastReleased = mappedButton;\r\n\t\t\t\t\tthisPlayer.interaction_mapped.gamepadType = 'keyboard';\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iterate through players and check for interaction with defined pointer buttons\r\n\t */\r\n\tcheckPointerInput() {\r\n\t\t// Loop through players and check for button presses\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\t// Loop through all the keys assigned to this player\r\n\t\t\tfor (var thisKey in thisPlayer.keys) {\r\n\t\t\t\tfor (var thisValue of thisPlayer.keys[thisKey]) { // Each definition for this key action\r\n\t\t\t\t\tif (['M1', 'M2', 'M3', 'M4', 'M5'].includes(thisValue[0])) {\r\n\t\t\t\t\t\t// Check to see if button is pressed (stored in P1, can't have two mice...)\r\n\t\t\t\t\t\tif (this.players[0].pointer[thisValue] == 1) {\r\n\t\t\t\t\t\t\tthisPlayer.buttons[thisKey] = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Gamepad functions\r\n\r\n\t/**\r\n\t * When a gamepad button is pressed down, this function will emit a mergedInput event in the global registry.\r\n\t * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\r\n\t * @param {number} index Button index\r\n\t * @param {number} value Button value\r\n\t * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\r\n\t */\r\n\tgamepadButtonDown(pad, button, value) {\r\n\t\tthis.players[pad.index].setDevice('gamepad');\r\n\t\tthis.players[pad.index].buttons.TIMESTAMP = this.scene.sys.time.now;\r\n\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: value, player: pad.index, action: 'B' + button.index, state: 'DOWN' });\r\n\t\tthis.events.emit('gamepad_buttondown', { player: pad.index, button: `B${button.index}` });\r\n\r\n\t\t// Buttons\r\n\t\tif (![12, 13, 14, 15].includes(button.index)) {\r\n\t\t\tlet playerAction = 'B' + button.index;\r\n\r\n\t\t\t// Update the last button state\r\n\t\t\tthis.players[pad.index].interaction.pressed.push(playerAction);\r\n\t\t\tthis.players[pad.index].interaction.last = playerAction;\r\n\t\t\tthis.players[pad.index].interaction.lastPressed = playerAction;\r\n\t\t\tthis.players[pad.index].interaction.buffer.push(playerAction);\r\n\r\n\t\t\t// Update timers\r\n\t\t\tthis.players[pad.index].timers[playerAction].pressed = this.scene.sys.time.now;\r\n\t\t\tthis.players[pad.index].timers[playerAction].released = 0;\r\n\t\t\tthis.players[pad.index].timers[playerAction].duration = 0;\r\n\r\n\t\t\t// Update mapped button object\r\n\t\t\tlet mappedButton = this.getMappedButton(this.players[pad.index], button.index);\r\n\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.pressed.push(mappedButton);\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.last = mappedButton;\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.lastPressed = mappedButton;\r\n\t\t\t} \r\n\t\t}\r\n\t\t// DPad\r\n\t\telse {\r\n\t\t\tlet dpadMapping = this.dpadMappings;\r\n\t\t\tlet direction = Object.keys(dpadMapping).find(key => dpadMapping[key] == button.index);\r\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: direction, state: 'DOWN' });\r\n\t\t\tthis.events.emit('gamepad_directiondown', { player: pad.index, button: direction });\r\n\r\n\t\t\tthis.players[pad.index].interaction.pressed.push(direction);\r\n\t\t\tthis.players[pad.index].interaction.last = direction;\r\n\t\t\tthis.players[pad.index].interaction.lastPressed = direction;\r\n\t\t\tthis.players[pad.index].interaction.buffer.push(direction);\r\n\t\t\tthis.players[pad.index].direction.TIMESTAMP = this.scene.sys.time.now;\r\n\r\n\t\t\t// Update timers\r\n\t\t\tthis.players[pad.index].timers[direction].pressed = this.scene.sys.time.now;\r\n\t\t\tthis.players[pad.index].timers[direction].released = 0;\r\n\t\t\tthis.players[pad.index].timers[direction].duration = 0;\r\n\r\n\r\n\t\t\t// Update mapped button object\r\n\t\t\tlet mappedButton = this.getMappedButton(this.players[pad.index], button.index);\r\n\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.pressed.push(mappedButton);\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.last = mappedButton;\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.lastPressed = mappedButton;\r\n\t\t\t} \r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * When a gamepad button is released, this function will emit a mergedInput event in the global registry.\r\n\t * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\r\n\t * @param {number} index Button index\r\n\t * @param {number} value Button value\r\n\t * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\r\n\t */\r\n\tgamepadButtonUp(pad, button, value) {\r\n\t\tthis.players[pad.index].setDevice('gamepad');\r\n\t\tthis.players[pad.index].buttons.TIMESTAMP = this.scene.sys.time.now;\r\n\r\n\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: value, player: pad.index, action: 'B' + button.index, state: 'UP' });\r\n\t\tthis.events.emit('gamepad_buttonup', { player: pad.index, button: `B${button.index}` });\r\n\r\n\t\t// Buttons\r\n\t\tif (![12, 13, 14, 15].includes(button.index)) {\r\n\t\t\tlet playerAction = 'B' + button.index;\r\n\r\n\t\t\t// Update the last button state\r\n\t\t\tthis.players[pad.index].interaction.released.push(playerAction);\r\n\t\t\tthis.players[pad.index].interaction.lastReleased = playerAction;\r\n\r\n\t\t\t// Update timers\r\n\t\t\tthis.players[pad.index].timers[playerAction].released = this.scene.sys.time.now;\r\n\t\t\tthis.players[pad.index].timers[playerAction].duration = this.players[pad.index].timers[playerAction].released - this.players[pad.index].timers[playerAction].pressed;\r\n\r\n\t\t\t// Update mapped button object\r\n\t\t\tlet mappedButton = this.getMappedButton(this.players[pad.index], button.index);\r\n\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.released = mappedButton;\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.lastReleased = mappedButton;\r\n\t\t\t} \r\n\t\t}\r\n\t\t// DPad\r\n\t\telse {\r\n\t\t\tlet dpadMapping = this.dpadMappings;\r\n\t\t\tlet direction = Object.keys(dpadMapping).find(key => dpadMapping[key] == button.index);\r\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'gamepad', value: 1, player: pad.index, action: direction, state: 'UP' });\r\n\t\t\tthis.events.emit('gamepad_directionup', { player: pad.index, button: direction });\r\n\r\n\t\t\tthis.players[pad.index].interaction.released.push(direction);\r\n\t\t\tthis.players[pad.index].interaction.lastReleased = direction;\r\n\r\n\t\t\t// Update timers\r\n\t\t\tthis.players[pad.index].timers[direction].released = this.scene.sys.time.now;\r\n\t\t\tthis.players[pad.index].timers[direction].duration = this.players[pad.index].timers[direction].released - this.players[pad.index].timers[direction].pressed;\r\n\r\n\t\t\t// Update mapped button object\r\n\t\t\tlet mappedButton = this.getMappedButton(this.players[pad.index], button.index);\r\n\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.released = mappedButton;\r\n\t\t\t\tthis.players[pad.index].interaction_mapped.lastReleased = mappedButton;\r\n\t\t\t} \r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Some gamepads map dpads to axis, which are handled differently to buttons.\r\n\t * This function mimics a gamepad push and fires an event.\r\n\t * We also insert the direction into a buffer so that we know what buttons are pressed in the gamepadFakeDPadRelease function\r\n\t * We use an array for the buffer and pressed vars, as more than one button may be pressed at the same time, within the same step.\r\n\t */\r\n\tgamepadFakeDPadPress(gamepad, direction) {\r\n\t\tif (!this.players[gamepad.index].internal.fakedpadBuffer.includes(direction)) {\r\n\t\t\tthis.players[gamepad.index].internal.fakedpadBuffer.push(direction);\r\n\t\t\tthis.players[gamepad.index].internal.fakedpadPressed.push(direction);\r\n\t\t\t\r\n\t\t\tlet thisButton = new Phaser.Input.Gamepad.Button(gamepad, this.dpadMappings[direction])\r\n\t\t\tthisButton.value = 1;\r\n\t\t\tthisButton.pressed = true;\r\n\t\t\tthisButton.events.emit('down', gamepad, thisButton, 1)\r\n\t\t\t// this.systems.input.gamepad.emit('down', gamepad, thisButton, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * When the axis is blank, we know we've released all buttons.\r\n\t */\r\n\tgamepadFakeDPadRelease(gamepad) {\r\n\t\tif (this.players[gamepad.index].internal.fakedpadBuffer.length > 0) {\r\n\r\n\t\t\tfor (let direction of this.players[gamepad.index].internal.fakedpadBuffer) {\r\n\t\t\t\tthis.players[gamepad.index].internal.fakedpadReleased = direction;\r\n\t\r\n\t\t\t\tlet thisButton = new Phaser.Input.Gamepad.Button(gamepad, this.dpadMappings[direction])\r\n\t\t\t\tthisButton.value = 0;\r\n\t\t\t\tthisButton.pressed = false;\r\n\t\t\t\tthisButton.events.emit('up', gamepad, thisButton, 0)\r\n\t\t\t\t// this.systems.input.gamepad.emit('up', gamepad, thisButton, 0);\r\n\t\t\t}\r\n\r\n\t\t\tthis.players[gamepad.index].internal.fakedpadBuffer = [];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Iterate through gamepads and handle interactions\r\n\t */\r\n\tcheckGamepadInput() {\r\n\t\t// Check for gamepad input\r\n\t\tfor (var thisGamepad of this.gamepads) {\r\n\r\n\t\t\t// Set up a player if we don't have one, presumably due to race conditions in detecting gamepads\r\n\t\t\tif (typeof this.players[thisGamepad.index] === 'undefined') {\r\n\t\t\t\tthis.addPlayer();\r\n\t\t\t}\r\n\r\n\t\t\tlet direction = '';\r\n\r\n\t\t\t// Directions\r\n\t\t\tif (thisGamepad.leftStick.y < -0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction.UP = Math.abs(thisGamepad.leftStick.y)\r\n\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\r\n\r\n\t\t\t\tif (thisGamepad.fakedpad) {\r\n\t\t\t\t\tthis.gamepadFakeDPadPress(thisGamepad, 'UP');\r\n\t\t\t\t\tdirection = 'UP'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (thisGamepad.leftStick.y > 0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction.DOWN = thisGamepad.leftStick.y\r\n\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t\r\n\t\t\t\tif (thisGamepad.fakedpad) {\r\n\t\t\t\t\tthis.gamepadFakeDPadPress(thisGamepad, 'DOWN');\r\n\t\t\t\t\tdirection = 'DOWN'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\r\n\t\t\t\t// DPad\r\n\t\t\t\tthis.players[thisGamepad.index].direction.UP = thisGamepad.up ? 1 : 0;\r\n\t\t\t\tthis.players[thisGamepad.index].direction.DOWN = thisGamepad.down ? 1 : 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (thisGamepad.leftStick.x < -0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction.LEFT = Math.abs(thisGamepad.leftStick.x)\r\n\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\r\n\r\n\t\t\t\tif (thisGamepad.fakedpad) {\r\n\t\t\t\t\tthis.gamepadFakeDPadPress(thisGamepad, 'LEFT');\r\n\t\t\t\t\tdirection = 'LEFT'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (thisGamepad.leftStick.x > 0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction.RIGHT = thisGamepad.leftStick.x\r\n\t\t\t\tthis.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t\r\n\t\t\t\tif (thisGamepad.fakedpad) {\r\n\t\t\t\t\tthis.gamepadFakeDPadPress(thisGamepad, 'RIGHT');\r\n\t\t\t\t\tdirection = 'RIGHT'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\r\n\t\t\t\t// DPad\r\n\t\t\t\tthis.players[thisGamepad.index].direction.LEFT = thisGamepad.left ? 1 : 0;\r\n\t\t\t\tthis.players[thisGamepad.index].direction.RIGHT = thisGamepad.right ? 1 : 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (thisGamepad.fakedpad && direction == '') {\r\n\t\t\t\tthis.gamepadFakeDPadRelease(thisGamepad);\r\n\t\t\t}\r\n\r\n\t\t\t// Secondary\r\n\t\t\tif (thisGamepad.rightStick.y < -0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.UP = Math.abs(thisGamepad.rightStick.y)\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t}\r\n\t\t\telse if (thisGamepad.rightStick.y > 0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.DOWN = thisGamepad.rightStick.y\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.UP = 0;\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.DOWN = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (thisGamepad.rightStick.x < -0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.LEFT = Math.abs(thisGamepad.rightStick.x)\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t}\r\n\t\t\telse if (thisGamepad.rightStick.x > 0.5) {\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.RIGHT = thisGamepad.rightStick.x\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.LEFT = 0;\r\n\t\t\t\tthis.players[thisGamepad.index].direction_secondary.RIGHT = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (this.players[thisGamepad.index].interaction.device === 'gamepad') {\r\n\t\t\t\t// Buttons\r\n\t\t\t\tfor (var b = 0; b < thisGamepad.buttons.length; b++) {\r\n\t\t\t\t\tlet button = thisGamepad.buttons[b];\r\n\t\t\t\t\tthis.players[thisGamepad.index].buttons['B' + b] = button.value;\r\n\r\n\t\t\t\t\t// Get mapped name for this button number and artificially update the relevant buttons_mapped key\r\n\t\t\t\t\tlet mappedButton = this.getMappedButton(this.players[thisGamepad.index], b);\r\n\t\t\t\t\tif (typeof mappedButton !== \"undefined\") {\r\n\t\t\t\t\t\tthis.players[thisGamepad.index].buttons_mapped[mappedButton] = button.value;\r\n\t\t\t\t\t} \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Function to run on pointer move.\r\n\t * @param {*} pointer - The pointer object\r\n\t */\r\n\tpointerMove(pointer, threshold) {\r\n\t\tif (this.players.length) {\r\n\t\t\tthreshold = threshold || 0;\r\n\t\t\tif (pointer.distance > threshold) {\r\n\t\t\t\tlet pointerDirection = this.getBearingFromAngle(pointer.angle, 8);\r\n\r\n\t\t\t\t// If we've been given a player position, return bearings and angles\r\n\t\t\t\tif (typeof this.players[0] !== 'undefined' && this.players[0].position.x !== 'undefined') {\r\n\t\t\t\t\tlet position = this.players[0].position;\r\n\t\t\t\t\tlet angleToPointer = Phaser.Math.Angle.Between(position.x, position.y, pointer.worldX, pointer.worldY);\r\n\t\t\t\t\tpointerDirection = this.getBearingFromAngle(angleToPointer, 8);\r\n\t\t\t\t\tlet pointerAngle = Number(this.mapBearingToDegrees(pointerDirection));\r\n\r\n\t\t\t\t\tthis.players[0].pointer.BEARING = pointerDirection;\r\n\t\t\t\t\tthis.players[0].pointer.ANGLE = angleToPointer;\r\n\t\t\t\t\tthis.players[0].pointer.BEARING_DEGREES = pointerAngle;\r\n\t\t\t\t\tthis.players[0].pointer.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Function to run on pointer down. Indicates that Mx has been pressed, which should be listened to by the player object\r\n\t * @param {*} pointer - The pointer object\r\n\t */\r\n\tpointerDown(pointer) {\r\n\t\tif (this.players.length) {\r\n\t\t\tlet action = '';\r\n\t\t\tthis.players[0].setDevice('pointer');\r\n\t\t\tif (pointer.leftButtonDown()) {\r\n\t\t\t\taction = 'M1';\r\n\t\t\t}\r\n\t\t\tif (pointer.rightButtonDown()) {\r\n\t\t\t\taction = 'M2';\r\n\t\t\t}\r\n\t\t\tif (pointer.middleButtonDown()) {\r\n\t\t\t\taction = 'M3';\r\n\t\t\t}\r\n\t\t\tif (pointer.backButtonDown()) {\r\n\t\t\t\taction = 'M4';\r\n\t\t\t}\r\n\t\t\tif (pointer.forwardButtonDown()) {\r\n\t\t\t\taction = 'M5';\r\n\t\t\t}\r\n\r\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'pointer', value: 1, player: 0, action: action, state: 'DOWN' });\r\n\t\t\tthis.events.emit('pointer_down', action);\r\n\r\n\t\t\tthis.players[0].pointer[action] = 1;\r\n\r\n\t\t\t// Update the last button state\r\n\t\t\tthis.players[0].interaction.pressed.push(action);\r\n\t\t\tthis.players[0].interaction.last = action;\r\n\t\t\tthis.players[0].interaction.lastPressed = action;\r\n\t\t\tthis.players[0].interaction.buffer.push(action);\r\n\t\t\tthis.players[0].pointer.TIMESTAMP = pointer.moveTime;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Function to run on pointer up. Indicates that Mx has been released, which should be listened to by the player object\r\n\t * @param {*} pointer - The pointer object\r\n\t */\r\n\tpointerUp(pointer) {\r\n\t\tif (this.players.length) {\r\n\t\t\tlet action = '';\r\n\t\t\tif (pointer.leftButtonReleased()) {\r\n\t\t\t\taction = 'M1';\r\n\t\t\t}\r\n\t\t\tif (pointer.rightButtonReleased()) {\r\n\t\t\t\taction = 'M2';\r\n\t\t\t}\r\n\t\t\tif (pointer.middleButtonReleased()) {\r\n\t\t\t\taction = 'M3';\r\n\t\t\t}\r\n\t\t\tif (pointer.backButtonReleased()) {\r\n\t\t\t\taction = 'M4';\r\n\t\t\t}\r\n\t\t\tif (pointer.forwardButtonReleased()) {\r\n\t\t\t\taction = 'M5';\r\n\t\t\t}\r\n\r\n\t\t\tthis.eventEmitter.emit('mergedInput', { device: 'pointer', value: 1, player: 0, action: action, state: 'UP' });\r\n\t\t\tthis.events.emit('pointer_up', action);\r\n\r\n\t\t\tthis.players[0].pointer[action] = 0;\r\n\t\t\tthis.players[0].interaction.released.push(action);\r\n\t\t\tthis.players[0].interaction.lastReleased = action;\r\n\t\t\tthis.players[0].pointer.TIMESTAMP = this.scene.sys.time.now;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n     * Create new button combo.\r\n\t * Combos extend Phaser's keyboard combo and mimic their functionality for gamepad/player combinations.\r\n\t * If you requrie a keyboard entered combo, use the native Phaser.Input.Keyboard.KeyboardPlugin.createCombo function.\r\n\t * \r\n\t * @param {player} player - A player object. If more than one player should be able to execute the combo, you should create multiple buttonCombo instances.\r\n     * @param {(object[])} buttons - An array of buttons that comprise this combo. Use button IDs, mapped buttons or directions, e.g. ['UP', 'UP', 'DOWN', 'DOWN', 'LEFT', 'RIGHT', 'LEFT', 'RIGHT', 'RC_E', 'RC_S']\r\n     * @param {Phaser.Types.Input.Keyboard.KeyComboConfig} [config] - A Key Combo configuration object.\r\n     */\r\n    createButtonCombo(player, buttons, config) {\r\n        return new ButtonCombo(this, player, buttons, config);\r\n    }\r\n\r\n\r\n\t/**\r\n\t * Get the bearing from a given angle\r\n\t * @param {float} angle - Angle to use\r\n\t * @param {number} numDirections - Number of possible directions (e.g. 4 for N/S/E/W)\r\n\t */\r\n\tgetBearingFromAngle(angle, numDirections) {\r\n\t\tnumDirections = numDirections || 8;\r\n\r\n\t\tvar snap_interval = Phaser.Math.PI2 / numDirections;\r\n\r\n\t\tvar angleSnap = Phaser.Math.Snap.To(angle, snap_interval);\r\n\t\tvar angleSnapDeg = Phaser.Math.RadToDeg(angleSnap);\r\n\t\tvar angleSnapDir = this.bearings[angleSnapDeg];\r\n\r\n\t\treturn angleSnapDir;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Given a bearing, return a direction object containing boolean flags for the four directions\r\n\t * @param {*} bearing\r\n\t */\r\n\tmapBearingToDirections(bearing) {\r\n\t\tlet thisDirection = {\r\n\t\t\t'UP': 0,\r\n\t\t\t'DOWN': 0,\r\n\t\t\t'LEFT': 0,\r\n\t\t\t'RIGHT': 0,\r\n\t\t\t'BEARING': bearing.toUpperCase()\r\n\t\t}\r\n\r\n\t\tif (bearing.toUpperCase().includes('W')) {\r\n\t\t\tthisDirection.LEFT = 1;\r\n\t\t}\r\n\t\tif (bearing.toUpperCase().includes('E')) {\r\n\t\t\tthisDirection.RIGHT = 1;\r\n\t\t}\r\n\t\tif (bearing.toUpperCase().includes('S')) {\r\n\t\t\tthisDirection.DOWN = 1;\r\n\t\t}\r\n\t\tif (bearing.toUpperCase().includes('N')) {\r\n\t\t\tthisDirection.UP = 1;\r\n\t\t}\r\n\r\n\t\treturn thisDirection;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Given a directions object, return the applicable bearing (8 way only)\r\n\t * @param {*} directions\r\n\t */\r\n\tmapDirectionsToBearing(directions, threshold) {\r\n\t\tvar threshold = threshold || -.5\r\n\t\tif (directions.UP && !(directions.LEFT || directions.RIGHT)) {\r\n\t\t\treturn 'N';\r\n\t\t}\r\n\t\tif (directions.RIGHT && directions.UP) {\r\n\t\t\treturn 'NE';\r\n\t\t}\r\n\t\tif (directions.RIGHT && !(directions.UP || directions.DOWN)) {\r\n\t\t\treturn 'E';\r\n\t\t}\r\n\t\tif (directions.RIGHT && directions.DOWN) {\r\n\t\t\treturn 'SE';\r\n\t\t}\r\n\t\tif (directions.DOWN && !(directions.LEFT || directions.RIGHT)) {\r\n\t\t\treturn 'S';\r\n\t\t}\r\n\t\tif (directions.LEFT && directions.DOWN) {\r\n\t\t\treturn 'SW';\r\n\t\t}\r\n\t\tif (directions.LEFT && !(directions.UP || directions.DOWN)) {\r\n\t\t\treturn 'W';\r\n\t\t}\r\n\t\tif (directions.LEFT && directions.UP) {\r\n\t\t\treturn 'NW';\r\n\t\t}\r\n\t\treturn '';\r\n\t}\r\n\r\n\t/**\r\n\t * Given a bearing, return the snapped angle in degrees\r\n\t * @param {*} bearing\r\n\t */\r\n\tmapBearingToDegrees(bearing) {\r\n\t\tif (bearing != '') {\r\n\t\t\treturn Object.keys(this.bearings).find(key => this.bearings[key] === bearing);\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn '';\r\n\t\t}\r\n\t}\r\n\r\n\tdestroy() {\r\n\t\tthis.shutdown();\r\n\t\tthis.scene = undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Return debug object\r\n\t */\r\n\tdebug() {\r\n\t\t// Debug variables\r\n\t\tvar debug = {\r\n\t\t\t'input': {}\r\n\t\t};\r\n\t\tdebug.input.gamepads = [];\r\n\t\t\r\n\t\tfor (var i = 0; i < this.gamepads.length; i++) {\r\n\t\t\tlet pad = this.gamepads[i];\r\n\t\t\tlet buttons = {};\r\n\t\t\tlet axes = {};\r\n\r\n\t\t\tfor (var b = 0; b < pad.buttons.length; b++) {\r\n\t\t\t\tlet button = pad.buttons[b];\r\n\t\t\t\tbuttons['B' + button.index] = button.value;\r\n\t\t\t}\r\n\r\n\t\t\tfor (var a = 0; a < pad.axes.length; a++) {\r\n\t\t\t\tlet axis = pad.axes[a];\r\n\t\t\t\taxes['A' + axis.index] = axis.getValue();\r\n\t\t\t}\r\n\r\n\t\t\tdebug.input.gamepads.push({\r\n\t\t\t\t'ID': pad.id,\r\n\t\t\t\t'Index': pad.index,\r\n\t\t\t\t'Buttons': buttons,\r\n\t\t\t\t'Axes': axes\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tdebug.players = [];\r\n\t\tfor (let thisPlayer of this.players) {\r\n\t\t\tdebug.players.push({\r\n\t\t\t\t'interaction': thisPlayer.interaction,\r\n\t\t\t\t'interaction_mapped': thisPlayer.interaction_mapped,\r\n//\t\t\t\t'device': thisPlayer.interaction.device,\r\n\t\t\t\t'buttons': thisPlayer.buttons,\r\n\t\t\t\t'buttons_mapped': thisPlayer.buttons_mapped,\r\n\t\t\t\t'timers': thisPlayer.timers,\r\n\t\t\t\t'pointer': thisPlayer.pointer,\r\n\t\t\t\t'direction': thisPlayer.direction,\r\n\t\t\t\t'direction_secondary': thisPlayer.direction_secondary,\r\n\t\t\t\t'keys': thisPlayer.keys\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\treturn debug;\r\n\t}\r\n}\r\n","const bearings = {\r\n    '-180': 'W',\r\n    '-168.75': 'WBN',\r\n    '-157.5': 'WNW',\r\n    '-146.25': 'NWBW',\r\n    '-135': 'NW',\r\n    '-123.75': 'NWBN',\r\n    '-112.5': 'NNW',\r\n    '-101.25': 'NBW',\r\n    '-90': 'N',\r\n    '-78.75': 'NBE',\r\n    '-67.5': 'NNE',\r\n    '-56.25': 'NEBN',\r\n    '-45': 'NE',\r\n    '-33.75': 'NEBE',\r\n    '-22.5': 'ENE',\r\n    '-11.25': 'EBN',\r\n    '0': 'E',\r\n    '11.25': 'EBS',\r\n    '22.5': 'ESE',\r\n    '33.75': 'SEBE',\r\n    '45': 'SE',\r\n    '56.25': 'SEBS',\r\n    '67.5': 'SSE',\r\n    '78.75': 'SBE',\r\n    '90': 'S',\r\n    '101.25': 'SBW',\r\n    '112.5': 'SSW',\r\n    '123.75': 'SWBS',\r\n    '135': 'SW',\r\n    '146.25': 'SWBW',\r\n    '157.5': 'WSW',\r\n    '168.75': 'WBS',\r\n    '180': 'W'\r\n};\r\n\r\nmodule.exports = bearings;","import pad_generic from './configs/pad_generic'\r\nimport pad_unlicensedSNES from './configs/pad_unlicensedSNES'\r\nimport pad_xbox360 from './configs/pad_xbox360'\r\nimport pad_dualshock from './configs/pad_dualshock'\r\n\r\nexport default class controlManager {\r\n    constructor (){\r\n    }\r\n\r\n    mapGamepad(id) {\r\n        id = id.toLowerCase();\r\n        let padConfig = pad_generic;\r\n\r\n        if (id.includes('081f') && id.includes('e401')) {\r\n            padConfig = pad_unlicensedSNES;\r\n        }\r\n        else if (id.includes('xbox') && id.includes('360')) {\r\n            padConfig = pad_xbox360;\r\n        }\r\n        else if (id.includes('054c')) {\r\n            padConfig = pad_dualshock;\r\n        }\r\n        else {\r\n            \r\n        }\r\n\r\n        return padConfig;\r\n    }\r\n\r\n    getBaseControls() {\r\n        return {\r\n            'direction': {\r\n                'UP': 0,\r\n                'DOWN': 0,\r\n                'LEFT': 0,\r\n                'RIGHT': 0,\r\n                'BEARING': '',\r\n                'BEARING_LAST': '',\r\n                'DEGREES': 0,\r\n                'DEGREES_LAST': 0,\r\n                'TIMESTAMP': 0\r\n            },\r\n            'direction_secondary': {\r\n                'UP': 0,\r\n                'DOWN': 0,\r\n                'LEFT': 0,\r\n                'RIGHT': 0,\r\n                'BEARING': '',\r\n                'DEGREES': 0,\r\n                'BEARING_LAST': '',\r\n                'DEGREES_LAST': 0,\r\n                'TIMESTAMP': 0\r\n            },\r\n            'buttons': {},\r\n            'timers' : {},\r\n            'gamepadMapping': {\r\n                RC_S: 0,\r\n                RC_E: 1,\r\n                RC_W: 2,\r\n                RC_N: 3,\r\n                START: 9,\r\n                SELECT: 8,\r\n                LB: 4,\r\n                RB: 5,\r\n                LT: 6,\r\n                RT: 7,\r\n                LS: 10,\r\n                RS: 11,\r\n                LC_N: 12,\r\n                LC_S: 13,\r\n                LC_W: 14,\r\n                LC_E: 15,\r\n                MENU: 16\r\n            },\r\n            'pointer': {\r\n                'M1': 0,\r\n                'M2': 0,\r\n                'M3': 0,\r\n                'M4': 0,\r\n                'M5': 0,\r\n                'BEARING': '',\r\n                'BEARING_DEGREES': 0,\r\n                'ANGLE': 0,\r\n                'TIMESTAMP': 0\r\n            },\r\n            'position': {x:0,y:0},\r\n            'gamepad': {},\r\n            'keys': {\r\n                'UP': [],\r\n                'DOWN': [],\r\n                'LEFT': [],\r\n                'RIGHT': [],\r\n            },\r\n            'internal': {\r\n                'fakedpadBuffer': [],\r\n                'fakedpadPressed': [],\r\n                'fakedpadReleased': [],\r\n            },\r\n            'interaction': {\r\n                'buffer': [],\r\n                'pressed': [],\r\n                'released': [],\r\n                'last': '',\r\n                'lastPressed': '',\r\n                'lastReleased': '',\r\n                'device': '',\r\n            },\r\n            'interaction_mapped': {\r\n                'pressed': [],\r\n                'released': [],\r\n                'last': '',\r\n                'lastPressed': '',\r\n                'lastReleased': '',\r\n                'gamepadType': '',\r\n            },\r\n            'buttons_mapped': {\r\n                RC_S: 0,\r\n                RC_E: 0,\r\n                RC_W: 0,\r\n                RC_N: 0,\r\n                START: 0,\r\n                SELECT: 0,\r\n                MENU: 0,\r\n                LB: 0,\r\n                RB: 0,\r\n                LT: 0,\r\n                RT: 0,\r\n                LS: 0,\r\n                RS: 0,\r\n                LC_N: 0,\r\n                LC_S: 0,\r\n                LC_W: 0,\r\n                LC_E: 0,\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Returns a struct to hold input control information\r\n     * Set up a struct for each player in the game\r\n     * Direction and Buttons contain the input from the devices\r\n     * The keys struct contains arrays of keyboard characters that will trigger the action\r\n     */\r\n    setupControls(numberOfButtons) {\r\n        numberOfButtons = numberOfButtons || 16;\r\n\r\n        let controls = this.getBaseControls();\r\n\r\n        // Add buttons\r\n        for (let i = 0; i <= numberOfButtons; i++) {\r\n            controls.buttons['B' + i] = 0;\r\n            controls.keys['B' + i] = [];\r\n        }\r\n\r\n        // Add timers \r\n        for (let i = 0; i <= numberOfButtons; i++) {\r\n            controls.timers['B' + i] = {\r\n                'pressed': 0,\r\n                'released': 0,\r\n                'duration': 0\r\n            };\r\n        }\r\n        for (let thisDirection of ['UP', 'DOWN', 'LEFT', 'RIGHT', 'ALT_UP', 'ALT_DOWN', 'ALT_LEFT', 'ALT_RIGHT']) {\r\n            controls.timers[thisDirection] = {\r\n                'pressed': 0,\r\n                'released': 0,\r\n                'duration': 0\r\n            };\r\n        }\r\n\r\n        for (let thisPointer of ['M1', 'M2', 'M3', 'M4', 'M5']) {\r\n            controls.timers[thisPointer] = {\r\n                'pressed': 0,\r\n                'released': 0,\r\n                'duration': 0\r\n            };\r\n        }\r\n\r\n\r\n        controls.setPosition = function(x,y) {\r\n            this.position.x = x;\r\n            this.position.y = y;\r\n        }\r\n        \r\n\r\n        return controls;\r\n    }\r\n\r\n\r\n}\r\n","/**\r\n * Generic pad mapping\r\n */\r\nmodule.exports = {\r\n    padID: 'Generic',\r\n    padType: 'generic',\r\n    gamepadMapping: {\r\n        RC_S: 0,\r\n        RC_E: 1,\r\n        RC_W: 2,\r\n        RC_N: 3,\r\n        START: 9,\r\n        SELECT: 8,\r\n        LB: 4,\r\n        RB: 5,\r\n        LT: 6,\r\n        RT: 7,\r\n        LS: 10,\r\n        RS: 11,\r\n        LC_N: 12,\r\n        LC_S: 13,\r\n        LC_W: 14,\r\n        LC_E: 15\r\n    },\r\n}","/**\r\n * 081f-e401 - UnlicensedSNES\r\n */\r\nmodule.exports = {\r\n    padID: '081f-e401',\r\n    padType: 'snes',\r\n    gamepadMapping : {\r\n        RC_S: 2,\r\n        RC_E: 1,\r\n        RC_W: 3,\r\n        RC_N: 0,\r\n        START: 9,\r\n        SELECT: 8,\r\n        LB: 4,\r\n        RB: 5,\r\n        LC_N: 12,\r\n        LC_S: 13,\r\n        LC_W: 14,\r\n        LC_E: 15\r\n    }\r\n}","/**\r\n * Generic pad mapping\r\n */\r\nmodule.exports = {\r\n    padID: 'Xbox 360 controller (XInput STANDARD GAMEPAD)',\r\n    padType: 'xbox',\r\n    gamepadMapping: {\r\n        RC_S: 0,\r\n        RC_E: 1,\r\n        RC_W: 2,\r\n        RC_N: 3,\r\n        START: 9,\r\n        SELECT: 8,\r\n        LB: 4,\r\n        RB: 5,\r\n        LT: 6,\r\n        RT: 7,\r\n        LS: 10,\r\n        RS: 11,\r\n        LC_N: 12,\r\n        LC_S: 13,\r\n        LC_W: 14,\r\n        LC_E: 15,\r\n        MENU: 16\r\n    },\r\n}","/**\r\n * Dualshock mapping\r\n */\r\nmodule.exports = {\r\n    padID: 'Dualshock',\r\n    padType: 'Sony',\r\n    gamepadMapping: {\r\n        RC_S: 0,\r\n        RC_E: 1,\r\n        RC_W: 2,\r\n        RC_N: 3,\r\n        START: 9, // Options\r\n        SELECT: 8, // Share\r\n        LB: 4,\r\n        RB: 5,\r\n        LT: 6,\r\n        RT: 7,\r\n        LS: 10,\r\n        RS: 11,\r\n        LC_N: 12,\r\n        LC_S: 13,\r\n        LC_W: 14,\r\n        LC_E: 15,\r\n        MENU: 16,\r\n        TOUCH: 17\r\n    },\r\n}","import AdvanceKeyCombo from 'phaser/src/input/keyboard/combo/AdvanceKeyCombo.js';\r\nimport ResetKeyCombo from 'phaser/src/input/keyboard/combo/ResetKeyCombo.js';\r\n\r\nexport default class ButtonCombo extends Phaser.Input.Keyboard.KeyCombo {\r\n    constructor(mergedInput, player, buttons, config) {\r\n        super(mergedInput.systems.input.keyboard, buttons, config);\r\n\r\n        this.player = player;\r\n        this.mergedInput = mergedInput;\r\n        this.keyCodes = buttons; // KeyCombo expects this to be an array of keycodes, we'll be checking against button names\r\n\r\n        mergedInput.events.on('gamepad_buttondown', this.onButtonDown, this);\r\n        this.current = this.keyCodes[0];\r\n    }\r\n\r\n    onButtonDown(event) {\r\n        if (this.matched || !this.enabled) {\r\n            return;\r\n        }\r\n\r\n        var matched = this.ProcessButtonCombo(event, this);\r\n        if (matched) {\r\n            this.mergedInput.eventEmitter.emit('mergedInput', { combo: this, player: this.player, action: 'Button combo matched' });\r\n            this.mergedInput.events.emit('buttoncombomatch', { player: this.player, combo: this });\r\n\r\n            if (this.resetOnMatch) {\r\n                ResetKeyCombo(this);\r\n            }\r\n            else if (this.deleteOnMatch) {\r\n                this.destroy();\r\n            }\r\n        }\r\n    }\r\n\r\n    ProcessButtonCombo (event, combo) {\r\n        // Don't check buttons on a different pad\r\n        if (combo.player.index !== event.player) { \r\n            return false;\r\n        }\r\n\r\n        // Check matched\r\n        if (combo.matched) {\r\n            return true;\r\n        }\r\n        \r\n        // Compare the current action with the button pressed\r\n        let buttonMatch = false;\r\n        if (event.button === combo.current) {\r\n            buttonMatch = true;\r\n        }\r\n\r\n        let mappedButton = this.mergedInput.getMappedButton(combo.player, event.button);\r\n        if (mappedButton === combo.current) {\r\n            buttonMatch = true;\r\n        }\r\n         \r\n        let unMappedButton = this.mergedInput.getUnmappedButton(combo.player, mappedButton);\r\n        if (unMappedButton === combo.current) {\r\n            buttonMatch = true;\r\n        }\r\n\r\n        var comboMatched = false;\r\n        var keyMatched = false;\r\n\r\n        if (buttonMatch) {\r\n            //  Button was correct\r\n\r\n            if (combo.index > 0 && combo.maxKeyDelay > 0) {\r\n                //  We have to check to see if the delay between\r\n                //  the new key and the old one was too long (if enabled)\r\n\r\n                var timeLimit = combo.timeLastMatched + combo.maxKeyDelay;\r\n\r\n                //  Check if they pressed it in time or not\r\n                if (event.timeStamp <= timeLimit) {\r\n                    keyMatched = true;\r\n                    comboMatched = AdvanceKeyCombo(event, combo);\r\n                }\r\n            }\r\n            else {\r\n                keyMatched = true;\r\n\r\n                //  We don't check the time for the first key pressed, so just advance it\r\n                comboMatched = AdvanceKeyCombo(event, combo);\r\n            }\r\n        }\r\n\r\n        if (!keyMatched && combo.resetOnWrongKey) {\r\n            //  Wrong key was pressed\r\n            combo.index = 0;\r\n            combo.current = combo.keyCodes[0];\r\n        }\r\n\r\n        if (comboMatched) {\r\n            combo.timeLastMatched = event.timeStamp;\r\n            combo.matched = true;\r\n            combo.timeMatched = event.timeStamp;\r\n        }\r\n\r\n        return comboMatched;\r\n    };\r\n\r\n\r\n    destroy() {\r\n        this.mergedInput.events.off('gamepad_buttondown', this.onButtonDown);\r\n        super.destroy();\r\n    }\r\n}","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2013-2023 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Used internally by the KeyCombo class.\n * Return `true` if it reached the end of the combo, `false` if not.\n *\n * @function Phaser.Input.Keyboard.AdvanceKeyCombo\n * @private\n * @since 3.0.0\n *\n * @param {KeyboardEvent} event - The native Keyboard Event.\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo object to advance.\n *\n * @return {boolean} `true` if it reached the end of the combo, `false` if not.\n */\nvar AdvanceKeyCombo = function (event, combo)\n{\n    combo.timeLastMatched = event.timeStamp;\n    combo.index++;\n\n    if (combo.index === combo.size)\n    {\n        return true;\n    }\n    else\n    {\n        combo.current = combo.keyCodes[combo.index];\n        return false;\n    }\n};\n\nmodule.exports = AdvanceKeyCombo;\n","/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2013-2023 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\n/**\n * Used internally by the KeyCombo class.\n *\n * @function Phaser.Input.Keyboard.ResetKeyCombo\n * @private\n * @since 3.0.0\n *\n * @param {Phaser.Input.Keyboard.KeyCombo} combo - The KeyCombo to reset.\n *\n * @return {Phaser.Input.Keyboard.KeyCombo} The KeyCombo.\n */\nvar ResetKeyCombo = function (combo)\n{\n    combo.current = combo.keyCodes[0];\n    combo.index = 0;\n    combo.timeLastMatched = 0;\n    combo.matched = false;\n    combo.timeMatched = 0;\n\n    return combo;\n};\n\nmodule.exports = ResetKeyCombo;\n"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n"],"sourceRoot":""}